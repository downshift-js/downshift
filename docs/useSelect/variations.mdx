---
name: Variations
menu: useSelect
route: /hooks/use-select/variations
---

import {useState} from 'react'
import {Playground} from 'docz'
import {useSelect} from '../../src'
import {items, menuStyles} from '../utils.json'

# useSelect

## Controlling state

Controlling state is possible by receiving the state changes done by Downshift
via onChange props (`onHighlightedIndexChange`, `onSelectedItemChange` etc.),
changing them based on your requirements and passing them back to Downshift via
props.

The example below shows how to control `selectedItem`. The value computed by
Downshift is received in `onSelectedItemChange` callback. The user checks it and
passes back a controlled value via`selectedChangeProp`. Here, for example, it
checks if `selectedItem` starts with the letter `C` and only then updates the
`selectedItem` in the widget. If not updated via prop, then the dropdown behaves
as if no item was selected.

### Playground

<Playground style={{height: '160px'}}>
  {() => {
    function Wrapper() {
      const [selectedItem, setSelectedItem] = useState()
      const onSelectedItemChange = item => {
        if (item.startsWith('C')) {
          setSelectedItem(item)
        }
      }
      return (
        <div>
          <div>{`${
            selectedItem ? 'Selection is ' + selectedItem + '! ' : ''
          }Select item starting with the letter C.`}</div>
          <DropdownSelect
            selectedItem={selectedItem}
            onSelectedItemChange={onSelectedItemChange}
          />
        </div>
      )
    }
    function DropdownSelect(props) {
      const {
        isOpen,
        selectedItem,
        getToggleButtonProps,
        getLabelProps,
        getMenuProps,
        highlightedIndex,
        getItemProps,
      } = useSelect({
        items,
        selectedItem: props.selectedItem,
        onSelectedItemChange: item => {
          props.onSelectedItemChange(item.selectedItem)
        },
      })
      return (
        <div>
          <label {...getLabelProps()}>Choose an element:</label>
          <button {...getToggleButtonProps()}>
            {selectedItem || 'Elements'}
          </button>
          <ul {...getMenuProps()} style={menuStyles}>
            {isOpen &&
              items.map((item, index) => (
                <li
                  style={
                    highlightedIndex === index
                      ? {backgroundColor: '#bde4ff'}
                      : {}
                  }
                  key={`${item}${index}`}
                  {...getItemProps({item, index})}
                >
                  {item}
                </li>
              ))}
          </ul>
        </div>
      )
    }
    return <Wrapper />
  }}
</Playground>

### CodeSandbox

Codesandbox equivalent is
[here](https://codesandbox.io/s/useselect-variations-controlling-state-8tvwj).

## State Reducer

For an even more granular control of the state changing process, you can add
your own reducer on top of the default one. When it's called it will receive the
previous `state` and the `actionAndChanges` object. This contains the change
`type`, which explains why the state is changed. It also contains the `changes`
proposed by `Downshift` that should occur as a consequence of that change type.
You are supposed to return the new state according to your needs.

In the example below, we are catching the selection event types,
`MenuKeyDownEnter` and `ItemClick` (we are disregarding `MenuBlur`). To keep
menu open, we are overriding `isOpen` with `state.isOpen` and `highlightedIndex`
with `state.highlightedIndex` to keep the same appearance to the user (menu open
with same item highlighted) after selection. But selection is still performed,
since we are also returning the destructured `actionAndChanges.changes` which
contains the `selectedItem` given to us by the `Downshift` default reducer.

In all other state change types, we return `Downshift` default changes.

### Playground

<Playground style={{height: '160px'}}>
  {() => {
    function stateReducer(state, actionAndChanges) {
      // this prevents the menu from being closed when the user selects an item with 'Enter' or mouse
      switch (actionAndChanges.type) {
        case useSelect.stateChangeTypes.MenuKeyDownEnter:
        case useSelect.stateChangeTypes.ItemClick:
          return {
            ...actionAndChanges.changes, // default Downshift new state changes on item selection.
            isOpen: state.isOpen, // but keep menu open.
            highlightedIndex: state.highlightedIndex, // with the item highlighted.
          }
        default:
          return actionAndChanges.changes // otherwise business as usual.
      }
    }

    const DropdownSelect = () => {
      const {
        isOpen,
        selectedItem,
        getToggleButtonProps,
        getLabelProps,
        getMenuProps,
        highlightedIndex,
        getItemProps,
      } = useSelect({items, stateReducer})
      return (
        <div>
          <label {...getLabelProps()}>Choose an element:</label>
          <button {...getToggleButtonProps()}>
            {selectedItem || 'Elements'}
          </button>
          <ul {...getMenuProps()} style={menuStyles}>
            {isOpen &&
              items.map((item, index) => (
                <li
                  style={
                    highlightedIndex === index
                      ? {backgroundColor: '#bde4ff'}
                      : {}
                  }
                  key={`${item}${index}`}
                  {...getItemProps({item, index})}
                >
                  {item}
                </li>
              ))}
          </ul>
        </div>
      )
    }
    return <DropdownSelect />

}}

</Playground>

### Codesandbox

Codesandbox equivalent is
[here](https://codesandbox.io/s/useselect-variations-state-reducer-ysc2r).
